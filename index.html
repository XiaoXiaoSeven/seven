<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    var obj = {
      'undefined': undefined,
      'null': null,
      'string': '123',
      'number': 123,
      'symbol': Symbol(123),
      'bigInt': BigInt(123312),
      'fn': function () { },
      'date': new Date(),
      're': new RegExp(/^\s$/),
      'arr': [1, 2, 3, 4, 5, 5],
      'obj': {
        a: 1,
        b: 2
      }
    }
    obj.obj.c = obj;
    Object.defineProperty(obj, 'innumerable', {
      value: '不可枚举属性',
      enumerable: false
    });

    function isObject(target) {
  const type = typeof target;
  return target !== null && (type === 'object' || type === 'function');
}

function cloneFunction(func) {
  const bodyReg = /(?<={)(.|\n)+(?=})/m;
  const paramReg = /(?<=\().+(?=\)\s+{)/;
  const funcString = func.toString();
  if (func.prototype) {
    const param = paramReg.exec(funcString);
    const body = bodyReg.exec(funcString);
    if (body) {
      console.log('匹配到函数体：', body[0]);
      if (param) {
        const paramArr = param[0].split(',');
        console.log('匹配到参数：', paramArr);
        return new Function(...paramArr, body[0]);
      } else {
        return new Function(body[0]);
      }
    } else {
      return null;
    }
  } else {
    return eval(funcString);
  }
}
function isObject(target) {
  const type = typeof target;
  return target !== null && (type === 'object' || type === 'function');
}

function getType(target) {
  return Object.prototype.toString.call(target);
}

function getInit(target) {
  const Ctor = target.constructor;
  return new Ctor();
}

function clone(target, map = new WeakMap()) {
  // 克隆原始数据类型
  if (!isObject(target)) {
    return target;
  }
  
  // 初始化
  let cloneTarget;

  // 防止循环引用
  if (map.get(target)) return map.get(target);
  map.set(target, target);

  // 克隆 Date
  if (getType(target) === '[object Date]') {
    return new Date(target)
  }

  // 克隆 正则
  if (getType(target) === '[object RegExp]') {
    return new RegExp(target);
  }

  // 克隆函数
  if (getType(target) === '[object Function]') {
    return cloneFunction(target)
  }

  // 克隆 set
  if (getType(target) === '[object Set]') {
    target.forEach((value) => {
      cloneTarget.add(clone(value, map));
    })
    return cloneTarget
  }

  // 克隆 map
  if (getType(target) === '[object Map]') {
    target.froEach((value, key) => {
      cloneTarget.set(key, clone(value, map));
    })
    return cloneTarget
  }

  // 克隆对象和数组
  cloneTarget = Array.isArray(target) ? [] : {};
  for (let key in target) {
    cloneTarget[key] = clone(target[key], map);
  }
  return cloneTarget;
}
 console.log(clone(obj))
  </script>
</body>

</html>